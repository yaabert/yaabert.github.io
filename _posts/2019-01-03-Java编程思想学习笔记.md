---

layout: post
title: "Java编程思想学习笔记"
categories: misc
author: "yaabert" 

---

## 学后有感
不保证都有用,只是想写下来.今天有感觉,就写得多一点好一些,今天例行公事么,那就那么回事吧
#### 继承和多态
两者放一起说吧,本来就不分家.            
继承要和类型一起说,像是一种扩展或者是类型之间的关系.当一个类型与另一个类型存在高度相似,并拥有更多的特性和能力.继承被用来形容两者的关系.存在源类,对特性和能力的抽象形容,则可以存在多个导出类(即子类),对源类的特性和能力进行不同的扩展和特殊说明.类似几何与具体形状例如圆或者角的关系.多态则是实现的具体方式.多态的存在又帮助了代码编译下的后期绑定.当存在明确对源类某种特性的明确使用时,再具体实现时可能会使用其导出类(即子类),比如运动员马拉松,在比赛中途慢跑,在终点冲刺.在不同环境下对特性和能力作调整.这在编译的初期是不知道的.直到运行期才被确定.这种时候Java使用一段特殊代码来替代绝对地址的调用,当程序运行时,去往实际被调用的地方.顺便说一下动态绑定下方法会调用实例类的方法,但是属性还是使用引用类的属性.
#### 单根继承结构
对象其实都是对某事或某物的抽象,基于抽象,必然是有共同点的.单根继承结构实现了对终点的确定.明确了该体系下的任何事物都具备某些共同的特性和能力.比如出生的方式,在堆上创建,对线程的操控能力,在垃圾回收器的眼中具备相同的身份实现了垃圾回收上的便利.

* 集合的存储对象皆为Object.(单根继承结构的好处 他lei了)
* 对象的向上转型必然是安全的(任何对象必然在根的下端).
* 线程的挂起通过硬件中断来实现(其实就是synchronized)
* synchronized现在拥有相当多的优化,可以自旋来不中断硬件等
* static属性属于class,而不是他的实例对象.class文件在虚拟机中存储在方法区中,而对象的实例存储在堆中.
* 任何对象只有在创建时才会被在堆中分配空间,而他需要的空间在程序编译时已经被确定了.

今天,就看了一点,先到这里吧


```
周末没看 周一有点事就也没看
```
又溜掉了一个周一 罪过啊。今天稍微看了下，先续着吧。有看总比没看强
 
#### 一切都是对象
在Java中几乎一切都可以视作是一种对象，在这里，我们并不直接操作对象的实例，就像看电视不用去到电视边上按按钮换台一样，我们使用对象的引用来操作对象，就像在房间里按遥控器一样。对象的实例储存在堆内存中，而引用存储在栈中。而且引用的生命周期和对象不相同，引用只活在他所在的作用域内，当程序执行到作用域之外时，这个时候引用其实已经死了，但是他绑定的对象实例却还在堆中存活。所以需要垃圾回收器来进行回收。假如两个不同的引用指向一个相同的对象，那么他们是equals和==其实是相同的都是true，就像是一台电视有两个遥控，其中一个选择换台，那个电视即会换台，即使另一个引用并没有对她所绑定的对象作出修改，也由不得他。

顺便说一下Java的基本类型除了八大类型外 还有一个void，他具有他基本类型也有的包装类叫Void。对了 每个普通方法都有返回值，即使他是用void修饰的，在方法末尾会有一个隐藏的return。

#### 特定的关键字 static
被static修饰，只属于类本身，在JVM载入class文件后的始初化中，static修饰的类、属性、方法都只始初化一次，你可以不生成类的实例也使用它的static属性。他不会与类的实例进行关联。他被储存在方法区中，只有一份。当你使用时，来这里找他，而不是去堆内存中的实例中找。

#### 初始化与清理
对象其实是由类产生的，类在JVM中体现应该是class文件。class文件记录了对象的信息。当我们需要一个对象时，需要按照class中的信息生成一个对象，这时候需要一个安全的方法，安全的生成对象。 lei了，构造方法他lei了。使用构造方法对类进行始初化，确保类的安全生成。正因此，构造方法必须不同于普通的方法他也不会拥有返回值，即使你使用它后得到一个对象实例，但是他本身确实没有返回任何东西。如果你没有为类编写构造方法，类本身会提供默认的无参构造方法，他只存在于你没有为类提供构造方法的前提下才会出现。
因为他是为了避免你因为疏忽或是因为不知道的情况编写错误，而当你为类提供了构造方法时，默认你知道构造方法的作用。就不再多事为你提供了。

顺便说一下方法的重载，重载类似行为的抽象，你可以洗东西，但是具体洗不同的东西应当具有不同的行为，但是他本质还是洗，如果硬要起名字区分他们太麻烦了，所以有了重载。你可以为这个行为定义不同情形下的具体行为。就算是参数的先后顺便变动或者返回值变动，都可以触发重载。当然不建议将参数先后顺序修改进行重载。后期维护比较难受。

#### 垃圾回收
这里不讲了 我在别处有写

#### 始初化的顺序
除了static、和final优先之外其他的基本就是按顺序进行。在类的内部，优先执行属性的始初化，再执行构造方法的始初化。  
还有枚举也是类。over ！

## 第六章 访问权限控制
#### 包:库单元
 面向对象设计中需要考虑的一个基本问题:"如何把变动的事物与保持不变的事物区分开来". 使用访问权限控制呀 private、public、protected.     
package(包)的存在使构件捆绑到一个内聚的类库单元,得以被控制.利用包将程序或者控件进行隔离.使之成为不相同的组件.配合单根继承结构,体系中不会因为存在相同的代码破坏了继承的体系和体系本身的安全.
#### 接口和实现
访问权限的控制常被称为是具体实现的隐藏.     
把数据和方法包装进类中,以及具体实现的隐藏,常共同被称作``` 封装```.其结果是一个同时带有特性和行为的数据类型.出于两个很重要的原因,访问权限控制将权限的边界划在了数据类型的内部.
 * 设定客户端程序员可以使用和不可以使用的界限,可以在结构中建立自己的内部机制,而不必担心客户端程序员会偶然的将内部机制当做是他们可以使用的接口的一部分
 * 接口和具体实现的分离. 分离的思想可大可小,大到系统架构上的设计,小到类的设计.都体现了分离.程序是一个大一些的类,类是一个小的程序.无论在什么样的关系中个成员所遵循的界限始终是很重要的,这代变着他们互相建立了连接或者是某种关系.
 
## 第七章 复 用 类
复用类的关键在于使用类二部破坏现有的代码程序.一般有两种方法.
* 一种为组合,在新的类中产生现有类的对象.因为新的类是由现有类的对象组成的,所以叫做组合.这种方法只是实现了现有类的功能,而非他的形式.
* 一种为继承,它更细致一些,他按照现有类的的类型来创建新类.采用现有类的形式,并在其中添加新的功能.继承是面向对象程序设计的基石之一.(我还不明白为什么)

#### 继承语法
继承是OOP语言和Java不可缺少的一部分.一个类除非明确继承自其它的对象,否则他就是隐式的继承自Object.(单根继承体系的双亲委派模式,还有单继承模式,只能继承一个类,虽然他可能继承自Object)但是过多的或者不必要的继承关系,会是结构繁琐,复杂,关系混乱.      
重点讲一下继承,继承涉及到两个类之间的关系,暂称为基类和导出类.
当创建一个导出类的对象时,该对象包含了一个基类的子对象.这个基类的子对象与你用基类直接创建的对象是一样的(导出类会继承public的方法和属性,不会继承private的方法和属性,构造方法也会被继承,当基类具备多个构造方法时,优先继承默认无参构造)两者的区别在于后者来自外部,而基类的子对象被包装在导出类对象的内部.
使用继承时编译器会强制你始初化基类,在构造器起始处就要去这样做,但是并不会强制你去始初化你的成员属性(又叫成员对象,因为万物皆对象,属性也是对象).
### 继承和组合
组合和继承都允许在新的类中放置子对象,组合是显式的这样做,而继承则是隐式的这样做.   
允许类的用户直接访问新类中的组合成分是极具意义的,将成员对象声明为public,但是隐藏他的具体实现,这时这种做法是安全的,同时方便用户在组装一部组件时,对端口更加的了解.      
在继承的时候,使用某个现有类通常意味着在使用一个通用类,并为了某种特殊需要而将其特殊化.就像用一个交通工具来实现一辆车子的功能.他们之间的关系更像是is-a(是一个)来表达,has-a(有一个)则更适合用来表达组合的关系.

### protected关键字
通常类的成员权限都设置为private,防止用户直接获取和修改他.但是某些时刻需要他尽可能的隐藏自己,却又要对外可见.protected的作用便显现出来了.同包内的其他类或者导出类可见.就用户而言他是隐藏的,但对同包内类或者导出类却是可见的,方便他们直接使用和修改.
### 向上转型

继承的重要方面之一:用来表现新类和基类之间的关系.这种关系可以形容为:新类是基类的一种类型.

在类型判断严格的Java中,可以将导出类当做基类进行传参之类的使用,,这是导出类会转换为基类.这种转换称为向上转型.(称为向上转型有其历史原因,传统类继承图绘制时,基类置于导出类上方,由导出类转型成基类,在继承图上是向上移动的). 可以看出向上转型是由一个专用类型或者特定类型转为通用类型.所以他总是很安全的,也就是导出类是基类的一个超集,他可能会比基类拥有更多方法,同时基类拥有方法,他也拥有.在向上转型时,以为这导出类会丢失一些方法,而不是去获得一些方法,这是为什么编译器在未曾明确表示转型或未曾指定特殊标记的情况下 仍然允许向上转型的原因.

### final关键字
根据上下文环境,final的含义会有细微的区别.但是通常情况下 final所带变的意义为 "这是不可改变的".通常情况下使用到 final的三种情况: 数据、方法、类.        
#### final数据
static属于类本身,不属于对象.final则表示所有类的该成员或者方法都是一个方法. 一个既是static修饰又是final的域只占据一段不能改变的存储空间. 在对final修饰的常量进行定义时,必须为其赋值.在修饰基本类型时,他表示final使数值恒定不变,在修饰引用时,final表示引用的指向永远不变.当修饰引用时,其实可以修改final最终的值.只要修改引用指向的值的内容时,可以达成修改final的值的效果.
#### 空白final
Java允许生成 "空白final"."空白final"是指被声明为final但又未给定初始值的域.无论什么情况下,编译器都必须保证"空白final"在被使用前必须被初始化.如此提供了极大的灵活性,可以做到根据对象而有所不同,却又保持其恒定不变的特性.即在final的定义处或者每个构造器中用表达式为final进行赋值.
#### final方法
使用final方法的原因有两个.
* 把方法锁死,确保继承类不会修改该方法的含义.
* 效率.

#### final和private关键字
类中所有private修饰 的方法都隐式的指定为final.由于无法取用private,也就无法覆盖.






