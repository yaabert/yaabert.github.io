---

layout: post
title: "JVM笔记"
categories: misc
author: "yaabert" 

---
## JVM学习

* 还没有开始只是偶尔看见好的材料记录一下


Java 1.8 使用元数据取代了永久代.元空间的本质和永久带类似.都是对JVM规范中的方法区的实现.其和永久代之间最大的区别在于,元数据空间不在JVM中,而在本地内存.

#### Java虚拟机栈
定义:描述Java方法运行过程的内存模型
Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做"栈帧"的区域,用于存放该方法运行过程中的一些信息,如局部变量表/操作数栈/动态链接/方法出口信息..等
#### 本地方法栈(C栈)
定义: 是为了JVM运行native方法准备的空间,由于很多native方法都是用C语言实现的,又叫C栈.与Java虚拟机栈实现的功能类似,不过本地方法栈描述本地方法运行过程的内存模型
#### 堆
定义: 堆是用来对象的内存空间,几乎所有的对象都存储在堆中     
特点: 
+ 线程共享,JVM只有一个堆,所有线程访问同一个堆.
+ 虚拟机启动时创建
+ 是垃圾回收的主要场所
+ 可以分为新生代和老年代
+ 堆大小可扩展,但当内存已无法再扩展时会throws OOM异常

#### 方法区
定义:Java虚拟机规范中定义方法区是堆的逻辑部分,存放 __已被虚拟机加载的类信息__/常亮/静态变量/即时编译后代码

#### JVM类加载
当Java虚拟机将Java源码编译为字节码之后,虚拟机便可以将字节码读取进内存,从而进行解析、运行的过程,这个过程 我们叫:Java虚拟机的类加载机制.JVM虚拟机执行class字节码的过程可以分为七个阶段:加载、验证、准备、解析、初始化、使用、卸载.

##### 准备阶段
当完成字节码的效验之后,JVM便会开始为类变量分配内存并始初化.这里需要注意两个关键点,即内存分配对象以及始初化的类型.        

+ 内存分配的对象    


        Java中的变量有[类变量]和[类成员变量]两种类型,[类变量]指的是被static修饰的变量,
    而其他的所有类型的变量都属于[类成员变量].在准备阶段,JVM只会为[类变量]分配内存,
    而不会为[类成员变量]分配内存.[类成员变量]的内存分配需要等到始初化阶段才开始.
    
+ 始初化的类型
        

        在准备阶段,JVM会为类变量分配内存,并未其始初化.但是里的始 初化指的是为
    变量赋予Java语言中该数据类型的零值,而不是用户代码里的始初值.


### JMM(Java内存模型)
Java线程之间的通信由Java内存模型控制.JMM决定一个线程对共享变量的写入何时对另一个线程可见. 内存模型中 内存又分为公共内存和本地内存,公共内存为所以线程共有,本地内存为线程私有.本地内存其实是JMM的一个抽象概念,并不真实存在.他涵盖了缓存,写缓冲区,寄存器以及其他的硬件和编译器优化. 
+ 不可变(final)
+ 可见性(volatile)
+ 有序性

### 线程之间的通信
Java线程之间的通信本质是公共内存和线程的私有内存之间的通信.

### 重排序
Java源代码的最终执行的指令序列,会经过三次排序.分别是编译器排序,指令级并行重排序,内存系统重排序.
+ __编译器优化重排序 :__ 编译器在不改变单线程程序语义的前提下可以重新安排语句的执行顺序
+ __指令级并行的重排序 :__ 处理器采用指令级并行技术奖多条指令重叠执行.如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序.
+ __内存系统的重排序 :__ 由于处理器使用缓存和读/写缓冲区,这使得加载和储存操作看上去可能是在乱序执行.

以上重排序都有可能呢过会导致多线程程序的内存可见性问题.同时为了保证内存可见性,Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序.

### happens-before
JDK5开始Java使用JSR-133内存模型.JSR-133使用happens-before的概念来阐述操作之间的内存可见性.在JMM中,如果一个操作执行的结果需要对另一个操作可见,那么这两个操作必须要存在happens-before关系.
A happens-before B时 如果执行A B重排序 执行后的结果和执行 A happens-before B的结果相同时,JMM会认为这种重排并不非法,会允许这种重排序.

### 顺序一致性
当程序未能正确同步时,就可能存在数据竞争.    
数据竞争的定义如下
+ 在一个线程中写一个变量
+ 在另一个线程读同一个变量
+ 而且写和读没有通过同步来排序

当一个多线程能正确同步,这个程序将是一个没有数据竞争的程序

### GC垃圾回收

__分代思想:__ 按照对象的声明周期长短将其分为了两个部分(新生代、老年代)     
__分区思想:__ 将整个堆空间划分为连续的不同小区间.

垃圾回收算法有三种: __标记清除算法__、__复制算法__、__标记压缩算法__.        

__标记清楚算法__    
算法分为两个阶段:标记阶段和清除阶段.在标记阶段,标记所有由GC Root 触发的可达对象.此时,未被标记的对象就是垃圾对象.之后在清除阶段,清除所有未被标记的对象.标记清除算法最大的问题就是空间碎片问题.如果空间碎片过多,则会导致内存空间的不连续.虽说大对象也可以分配在不连续的空间中,但是效率要低于连续的内存空间.

__复制算法__        
复制算法的核心思想是将原有的内存空间分为两块,每次只使用一块,在垃圾回收时,将正在使用的内存中的存活对象复制到未使用的内存块中.之后清除正在使用的内存块中的所有对象,之后交换两个内存快的角色,完成垃圾回收.该算法的缺点是要讲内存空间折半,极大的浪费了内存空间.

__标准压缩算法__        
标记压缩算法可以说是标记清除算法的优化版,其同样需要经历两个阶段,分别是:标记结算、压缩阶段.在标记阶段,从GC Root引用集合出发去标记所有对象.在压缩阶段,则是将所有存活的对象压缩在内存的一遍,之后清理边界外的所有空间.

#### JVM分代算法
所谓的分代算法,就是根据JVM内存的不用内存区域,采用不同的垃圾回收算法.例如对于存活对象少的新生代区域,比较适合采用复制算法.只需复制少量对象,便可以完成垃圾回收,并且不会有内存碎片.对于老年代这种存活对象多的区域,比较适合采用标记压缩算法或者标记清除算法,这样不需要移动太多的内存对象.          

        新生代的特点是存活对象少,适合采用复制算法.而复制算法的一种最简单的实现便是
    折半内存使用,另一半备用.但实际上JVM新生代划分中并不是采用等分位两块的内存
    的形式,而是分:Eden区域、from区域、to区域这三个区域.
    
    原因为新生代的对象98%是朝生夕死,并不需要按照1:1的比例来划分内存空间.所以在
    HotSpot虚拟机中,JVM将内存划分为一块较大的Eden空间和两块较小的Survivor空间
    ,其大小占比为8:1:1.当回收时,将Eden和Survicor中还存活的对象一次性复制到另一
    块Survivor空间上,最后清理掉Eden和刚才用过的Eden空间.

#### JVM分区思想
将堆空间划分为连续的不同小区间.每个小区间都独立使用,独立回收,这样算法的好处是可以控制一次回收多少个区间,可以较好地控制GC时间.
![image](https://note.youdao.com/yws/public/resource/d3b662818cefc1e557069e8ac495586d/xmlnote/D434E3CDB6DA47C5BAAAEC2B2065C3B1/2350)




### Java垃圾回收类型
+ __Serial GC__(-XX:+UseSerialGC):Serial GC使用简单的 __标记__、__清除__、__压缩__ 方法对新生代和老年代进行垃圾回收,即Minor GC和Major GC. Serial GC在client模式(客户端模式)很有用,比如在简单的独立应用和CPU配置低的机器,这个模式对占用内存较少的应用很管用.
+ __Parallel GC(-XX:+UseParallelGC)__:除了会产生N个线程来进行新生代的垃圾手机外,Parallel GC几乎一样.这里的N事系统CPU的核数.我们可以使用-XX:Parallel GCThreads=n 这个JVM选项来控制线程数量.并行垃圾收集器也叫throughput收集器.因为它使用了多CPU加快垃圾回收性能.Parallel GC在进行老年代垃圾收集时使用单线程.
+ __Parallel Old GC(-XX:+UseParallelOldGC)__:和Parallel GC一样.不同之处,Parallel Old GC在新生代垃圾收集和老年代垃圾回收时都是用多线程收集
+ __并发标记清除(CMS)收集器(-XX:+UseConcMarkSweepGC)__:CMS收集器也被称为短暂停顿并发收集器.它是对老年代进行垃圾收集的.CMS收集器通过多线程并发进行垃圾回收,尽量减少垃圾收集造成的停顿.CMS收集器对新生代进行垃圾回收使用的算法和Parallel收集器一样.这个垃圾收集器适用于不能忍受长时间停顿,要求快速响应的应用.可使用:ParallelCMSThreads=JVM选项来限制CMS收集器的线程数量
+ __G1垃圾收集器(-XX:+UseG1GC)__ G1(Garbage First): 垃圾收集器是在Java 7后才可以使用的特性,它的长远目标代替CMS收集器.G1收集器是一个并行的、并发的增量式压缩短暂停顿的垃圾收集器.G1收集器和其他的收集器运行方式不一样,不区分新生代和老年代空间.它吧堆空间划分为多个大小相等的区域.当进行垃圾收集时,它会优先收集存活对象比较的区域,因此叫"Garbage First". 可以参照[Oracle Garbage-First收集器文档](https://docs.oracle.com/javase/7/docs/technotes/guides/vm/G1.html)得到更多详细信息.

