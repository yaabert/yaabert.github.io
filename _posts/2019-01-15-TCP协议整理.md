## TCP协议

#### 滑动窗口
滑动窗口分为接受窗口和发送窗口  
滑动窗口协议是传输层进行流量控制的一种措施,接受放通过通告发送方自己的窗口大小,从而控制发送方的发送速度,从而达到防止发送方发送速度过快而导致自己被淹没的目的.

AKC的再认知,ack通常被理解为收到数据后给出的一个确认ACK,ACK包含两个非常重要的信息:     
__一、是期望接收到的下一个字节的序号n,该n代表接受方已经接收到了前n-1字节数据,此时如果接受方收到第n+1字节数据而不是第n字节数据,接受方是不会发送序列号为n+2的ACK的.__ 举个例子,加入接收端收到1-1024字节,他会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072,它是不会发送确认号为3072的ACK,而依旧发送1025的ACK   
__二、当前窗口大小m,如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方,假定当前发送方已经发送到第x字节,则可以发送的字节数就是y=m-(x-n)这个就是滑动窗口控制流量的基本原理.__

实际即为A(发送端)、B(接收端).建立连接时,B即通知A接收窗口大小,假定为窗口大小300,报文总长度400,A向B发送报文序列1-100,还能再发送200个字节,A向B发送报文序列101-200,还能再发送100字节,A向B发送报文序号201-300,还能再发送0字节.B收到1-100以及200-300的报文,中间内容丢失.此时B向A发送报文ACK=101,rwnd=200(允许A发送序号为101到300字节),A超时重传旧的数据(101-200),B接收到前300字节向A发送报文ack=301,rwnd=100,A发送301到400字节.四次挥手断开连接.

#### 三次握手 四次挥手
欠一哈,改天补上(最近沉迷下棋,改天补2019-01-15)   
##### 三次握手中SYN和ACK字段的作用 
```
2019-01-16 补 2019-01-15的遗漏,不代表完善了 以后还会持续更新TCP信息
```

客户端第一次握手时发生一个SYN字段表示自己的初始序列号ISN(c).服务端收到后进行第二次握手,会返回一个SYN字段和ACK字段,此处SYN字段与第一次握手相同表示自己的初始序列号ISN(c),ACK为之前收到的客户端SYN字段+1作为ACK返回.第三次握手时为了确定服务器的SYN,客户端将收到的SYN+1作为ACK返回.
##### 四次挥手
同理,不同的时服务端在连接的断开时刻由服务端决定,断开请求由客户端发起.客户端发送完了数据包,会发起断开请求称第一次挥手.服务端收到后回应准许断开称第二次挥手.然后服务器开始检查数据包的完整性等一系列操作,都都确定接受完成后准备关闭,然后给客户端发送,可以进行断开了称第三次挥手,在收到第二次挥手的时候客户端还没有实际断开,在和服务端一样进行准备断开,此时服务端要是有漏包之类的情况,会马上退出准备断开,进行重发,然后再次进入准备断开.在收到第三次挥手请求后,客户端返回确认断开信息给服务端称第四次挥手,然后断开.服务端收到请求后也断开连接.

##### ISN(SYN)

被用作交互确认信息的字段,如果为固定值的话,极容易被发现后续序列号,修改服务另做他用.
```
ISN = M + F(localhost + localport + remotehost + remoteport )
```

M 是一个计时器 每隔四毫秒 + 1   
F 是一个Hash算法,根据源IP + 源端口 + 目的IP +目的端口生成的随机值.

##### 序列号回绕
因为ISN随机产生,所以序列号就会容易超过2<sup>32</sup>-1,而TCP对于丢包、乱序等问题的判断都是依赖于序列号大小比较的.因此出现了序列号回绕问题.(超过2<sup>31</sup>后回绕到0)

```
/*
* The next routines deal with comparing 32 bit unsigned ints
* and worry about wraparound (automatic with unsigned arithmetic).
*/
static inline int before(__u32 seq1, __u32 seq2)
{
return (__s32)(seq1-seq2) < 0;
}
#define after(seq2, seq1) before(seq1, seq2)
```
这里_u32是无符号整型, _s32是有符号整型   
此处假设seq1 = 255 , seq2 = 1(发生了回绕)   
seq1 = 1111 1111 seq2 = 0000 0001
```
 seq1 - seq2=
 1111 1111
-0000 0001
-----------
 1111 1110
 ```
 此时是有符号数,由于最高为为1,因此结果是个复数.得出 seq1 - seq2 < 0. 得出此时回绕了.
 
 如果seq2=128的话，我们会发现：
 ```
 seq1 - seq2=
 1111 1111
-1000 0000
-----------
 0111 1111
 ```
 有符号数 ,高位为0 此时为正数 seq1 -seq2 >0, 判断没有发生回绕.    
 前提是回绕后的增量小于2<sup>n-1</sup>-1 ,在内核中判断是否回绕.